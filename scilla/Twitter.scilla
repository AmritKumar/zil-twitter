scilla_version 0

import BoolUtils IntUtils PairUtils

(* Twitter contract *)

(***************************************************)
(*               Associated library                *)
(***************************************************)
library Twitter

let one_msg =
    fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let one = Uint32 1

let not_owner_code = Uint32 0
let deposit_success_code = Uint32 1
let registration_error_code = Uint32 2
let registered_success_code = Uint32 3
let user_not_exists_code = Uint32 4
let tweet_exists_code = Uint32 5
let tweet_not_valid_code = Uint32 6
let tweet_within_day_code = Uint32 7
let verify_tweet_success_code = Uint32 8

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Twitter
(owner: ByStr20,
hashtag: String,
zils_per_tweet : Uint128,
blocks_per_day : Uint32)

field hashtag_length : Uint32 = builtin strlen hashtag

field users: Map String ByStr20
    = Emp String ByStr20

field verified_tweets: Map String ByStr20
    = Emp String ByStr20

field last_withdrawal: Map ByStr20 BNum
    = Emp ByStr20 BNum

(* Only owner can deposit ZIL *)
transition deposit()
    sender_is_owner = builtin eq owner _sender;
    match sender_is_owner with
    | False =>
        e = {_eventname : "deposit_failed";
                sender: _sender;
                code: not_owner_code };
        event e
    | True =>
        accept;
        e = {_eventname : "deposit_successful";
                sender: _sender;
                code: deposit_success_code };
        event e
    end
end

(* Only user that has not registered can register *)
transition register_user(user_address: ByStr20, twitter_username: String)
    sender_is_owner = builtin eq owner _sender;
    user_exists <- exists users[twitter_username];
    user_does_not_exist = negb user_exists;
    can_register = andb sender_is_owner user_does_not_exist;
    match can_register with
    | False =>
        e = {_eventname : "user_registration_failed";
                user_address: user_address;
                twitter_username: twitter_username;
                sender: _sender;
                code: registration_error_code };
      event e
    | True =>
        users[twitter_username] := user_address;
        e = {_eventname : "user_registration_successful";
                user_address: user_address;
                twitter_username: twitter_username;
                sender: _sender;
                code: registered_success_code };
        event e
    end
end


(* this is sent by the owner *)
transition verify_tweet_pay (
  twitter_username: String,
  tweet_id: String, tweet_text: String,
  start_pos: Uint32, end_pos: Uint32)

  is_owner = builtin eq _sender owner;

  match is_owner with
  | False =>
      e = {_eventname : "verify_tweet_failed";
              sender: _sender;
              twitter_username: twitter_username;
              tweet_id: tweet_id;
              code: not_owner_code };
      event e
  | True =>
      recipient_address_opt <- users[twitter_username];

      match recipient_address_opt with
      | None =>
          e = {_eventname : "verify_tweet_failed";
                  sender: _sender;
                  twitter_username: twitter_username;
                  tweet_id: tweet_id;
                  code: user_not_exists_code };
          event e
      | Some recipient_address =>
          already_verified <- exists verified_tweets[tweet_id];
          not_already_verified = negb already_verified;
          tweet_length = builtin strlen tweet_text;
          string_length = builtin strlen tweet_text;
          valid_end_pos = builtin lt end_pos string_length;
          valid_start_pos = builtin lt start_pos end_pos;
          is_valid_substring = andb valid_start_pos valid_end_pos;
          is_valid = andb is_valid_substring not_already_verified;

          match is_valid with
          | False =>
              match already_verified with
              | True =>
                  e = {_eventname : "verify_tweet_failed";
                          sender: _sender;
                          twitter_username: twitter_username;
                          tweet_id: tweet_id;
                          code: tweet_exists_code };
                  event e
              | False =>
                  e = {_eventname : "verify_tweet_failed";
                          sender: _sender;
                          twitter_username: twitter_username;
                          tweet_id: tweet_id;
                          code: tweet_not_valid_code };
                  event e
              end
          | True =>
              substr_len = builtin sub end_pos start_pos;
              substr_len = builtin add substr_len one;
              match_hashtag = builtin substr tweet_text start_pos substr_len;
              is_hashtag = builtin eq match_hashtag hashtag;

              match is_hashtag with
              | False =>
                  e = {_eventname : "verify_tweet_failed";
                          sender: _sender;
                          twitter_username: twitter_username;
                          tweet_id: tweet_id;
                          code: tweet_not_valid_code };
                  event e
              | True =>

                  withdrawal <- last_withdrawal[recipient_address];
                  current_block <- & BLOCKNUMBER;
                  not_next_day_yet =
                      match withdrawal with
                      | Some withdrawal =>
                          let last_withdraw_block = withdrawal in
                          let next_day_block = builtin badd last_withdraw_block blocks_per_day in
                          let not_next_day_yet = builtin blt current_block next_day_block in
                          not_next_day_yet
                      | None =>
                          False
                      end
                  ;

                  match not_next_day_yet with
                  | True =>
                      e = {_eventname : "verify_tweet_failed";
                              sender: _sender;
                              twitter_username: twitter_username;
                              tweet_id: tweet_id;
                              code: tweet_within_day_code };
                      event e
                  | False =>
                      verified_tweets[tweet_id] := recipient_address;
                      last_withdrawal[recipient_address] := current_block;
                      e = {_eventname : "verify_tweet_successful";
                              sender: _sender;
                              recipient: recipient_address;
                              reward_amount: zils_per_tweet;
                              tweet_id: tweet_id;
                              code: verify_tweet_success_code };
                      event e;
                      msg = {_tag: "";
                              _recipient: recipient_address;
                              _amount: zils_per_tweet;
                              code: verify_tweet_success_code };
                      msgs = one_msg msg;
                      send msgs
                  end
              end
          end
      end
  end
end
