scilla_version 0

import BoolUtils ListUtils PairUtils

(* Twitter contract *)

(***************************************************)
(*               Associated library                *)
(***************************************************)
library Twitter

let one_msg = 
    fun (msg : Message) => 
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let false = False
let true = True
let zero = Uint128 0
let one = Uint32 1

let not_owner_code = Uint32 0
let deposit_success_code = Uint32 1
let user_exists_code = Uint32 2
let registered_success_code = Uint32 3
let user_not_exists_code = Uint32 4
let tweet_exists_code = Uint32 5
let new_tweet_success_code = Uint32 6
let tweet_not_added_code = Uint32 7
let tweet_not_valid_code = Uint32 8
let tweet_within_day_code = Uint32 9
let verify_tweet_success_code = Uint32 10

let zils_per_tweet = Uint128 5
let blocks_per_day = Uint32 1103

let is_owner =
    fun (owner_address: ByStr20) =>
    fun (address: ByStr20) =>
        builtin eq owner_address address

let lte =
    fun (a: Uint128) =>
    fun (b: Uint128) =>
        let a_lt_b = builtin lt a b in
        let a_eq_b = builtin eq a b in
        orb a_lt_b a_eq_b

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Twitter
(owner: ByStr20,
hashtag: String)

field users: Map ByStr20 String
    = Emp ByStr20 String

field used_usernames: Map String Bool
    = Emp String Bool

field unverified_tweets: Map String ByStr20
    = Emp String ByStr20

field verified_tweets: Map String ByStr20
    = Emp String ByStr20

field last_withdrawal: Map ByStr20 BNum 
    = Emp ByStr20 BNum

(* Only owner can deposit ZIL *)
transition deposit()
    sender_is_owner = is_owner owner _sender;
    match sender_is_owner with
    | False =>
        e = {_eventname : "deposit_failed";
                sender: _sender;
                code: not_owner_code };
        event e
    | True =>
        accept;
        e = {_eventname : "deposit_successful";
                sender: _sender;
                code: deposit_success_code };
        event e
    end
end

(* Only user that has not registered can register *)
transition register_user(user_address: ByStr20, twitter_username: String)
    user_exists <- exists users[user_address];
    username_exists <- exists used_usernames[twitter_username];
    
    already_exists = orb user_exists username_exists;
    match already_exists with
    | True =>
        e = {_eventname : "user_registration_failed";
                user_address: user_address;
                twitter_username: twitter_username;
                sender: _sender;
                code: user_exists_code };
        event e
    | False =>
        users[user_address] := twitter_username;
        used_usernames[twitter_username] := true;

        e = {_eventname : "user_registration_successful";
                user_address: user_address;
                twitter_username: twitter_username;
                sender: _sender;
                code: registered_success_code };
        event e
    end
end

(* Tweets are added to pending verification *)
transition new_tweet(tweet_id: String)
    username <- users[_sender];

    match username with
    | None =>
        e = {_eventname : "add_new_tweet_failed";
                sender: _sender;
                username: "";
                tweet_id: tweet_id;
                code: user_not_exists_code };
        event e        
    | Some username =>
        tweet_unverified <- exists unverified_tweets[tweet_id];
        tweet_verified <- exists verified_tweets[tweet_id];
        tweet_exists = orb tweet_verified tweet_unverified;
        match tweet_exists with
        | True =>
            e = {_eventname : "add_new_tweet_failed";
                    sender: _sender;
                    username: username;
                    tweet_id: tweet_id;
                    code: tweet_exists_code };
            event e               
        | False =>
            unverified_tweets[tweet_id] := _sender;

            e = {_eventname : "add_new_tweet_sucessful";
                    sender: _sender;
                    username: username;
                    tweet_id: tweet_id;
                    code: new_tweet_success_code };
            event e
        end
    end
end

(* this is sent by the owner *)
transition verify_tweet(
    user_address: ByStr20,
    tweet_id: String, tweet_text: String,
    start_pos: Uint32, end_pos: Uint32
)
    is_owner = builtin eq _sender owner;

    match is_owner with
    | False =>
        e = {_eventname : "verify_tweet_failed";
                sender: _sender;
                user_address: user_address;
                tweet_id: tweet_id;
                code: not_owner_code };
        event e            
    | True =>
        is_unverified_tweet <- unverified_tweets[tweet_id];

        match is_unverified_tweet with
        | None =>
            e = {_eventname : "verify_tweet_failed";
                    sender: _sender;
                    user_address: user_address;
                    tweet_id: tweet_id;
                    code: tweet_not_added_code };
            event e                
        | Some recipient_address =>
            is_verified <- exists verified_tweets[tweet_id];
            not_is_verified = negb is_verified;
            is_valid_address = builtin eq recipient_address user_address;
            is_valid = andb is_valid_address not_is_verified;
            tweet_length = builtin strlen tweet_text;
            valid_start_pos =
                let start_pos_128_option = builtin to_uint128 start_pos in
                match start_pos_128_option with
                | None =>
                    False
                | Some start_pos_128 =>
                    let is_non_negative = lte zero start_pos_128 in
                    is_non_negative
                end
            ;
            string_length = builtin strlen tweet_text;
            valid_end_pos = builtin lt end_pos string_length;
            is_valid_substring = andb valid_start_pos valid_end_pos;
            is_valid = andb is_valid_substring is_valid;

            match is_valid with
            | False =>
                match is_verified with
                | True =>
                    delete unverified_tweets[tweet_id];
                    e = {_eventname : "verify_tweet_failed";
                            sender: _sender;
                            user_address: user_address;
                            tweet_id: tweet_id;
                            code: tweet_exists_code };
                    event e
                | False =>
                    e = {_eventname : "verify_tweet_failed";
                            sender: _sender;
                            user_address: user_address;
                            tweet_id: tweet_id;
                            code: tweet_not_valid_code };
                    event e
                end
            | True =>
                substr_len = builtin sub end_pos start_pos;
                substr_len = builtin add substr_len one;
                match_hashtag = builtin substr tweet_text start_pos substr_len;
                is_hashtag = builtin eq match_hashtag hashtag;

                match is_hashtag with
                | False =>
                    e = {_eventname : "verify_tweet_failed";
                            sender: _sender;
                            user_address: user_address;
                            tweet_id: tweet_id;
                            code: tweet_not_valid_code };
                    event e    
                | True =>

                    withdrawal <- last_withdrawal[user_address];
                    current_block <- & BLOCKNUMBER;
                    not_next_day_yet =
                        match withdrawal with
                        | Some withdrawal =>
                            let last_withdraw_block = withdrawal in
                            let next_day_block = builtin badd last_withdraw_block blocks_per_day in
                            let not_next_day_yet = builtin blt current_block next_day_block in
                            not_next_day_yet
                        | None =>
                            False    
                        end
                    ;
                    
                    match not_next_day_yet with
                    | True =>
                        e = {_eventname : "verify_tweet_failed";
                                sender: _sender;
                                user_address: user_address;
                                tweet_id: tweet_id;
                                code: tweet_within_day_code };
                        event e   
                    | False =>
                        verified_tweets[tweet_id] := user_address;
                        delete unverified_tweets[tweet_id];
                        last_withdrawal[user_address] := current_block;
                        e = {_eventname : "verify_tweet_successful";
                                sender: _sender;
                                recipient: user_address;
                                reward_amount: zils_per_tweet;
                                tweet_id: tweet_id;
                                code: verify_tweet_success_code };
                        event e;    
                        msg = {_tag: "";
                                _recipient: user_address;
                                _amount: zils_per_tweet;
                                code: verify_tweet_success_code };
                        msgs = one_msg msg;
                        send msgs
                    end
                end       
            end
        end
    end
end