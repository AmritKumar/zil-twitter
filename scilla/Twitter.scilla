scilla_version 0

import BoolUtils IntUtils PairUtils

(* Twitter contract *)

(***************************************************)
(*               Associated library                *)
(***************************************************)
library Twitter

let one_msg =
    fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

let one = Uint32 1

let not_owner_code = Uint32 0
let deposit_success_code = Uint32 1
let registration_error_code = Uint32 2
let registered_success_code = Uint32 3
let invalid_submission = Uint32 4
let verify_tweet_success_code = Uint32 5

(***************************************************)
(*             The contract definition             *)
(***************************************************)

contract Twitter
(owner: ByStr20,
hashtag: String,
zils_per_tweet : Uint128,
blocks_per_day : Uint32)

field hashtag_length : Uint32 = builtin strlen hashtag

field users: Map String ByStr20
    = Emp String ByStr20

field verified_tweets: Map String ByStr20
    = Emp String ByStr20

field last_withdrawal: Map ByStr20 BNum
    = Emp ByStr20 BNum

(* Only owner can deposit ZIL *)
transition deposit()
    sender_is_owner = builtin eq owner _sender;
    match sender_is_owner with
    | False =>
        e = {_eventname : "deposit_failed";
                sender: _sender;
                code: not_owner_code };
        event e
    | True =>
        accept;
        e = {_eventname : "deposit_successful";
                sender: _sender;
                code: deposit_success_code };
        event e
    end
end

(* Only user that has not registered can register *)
transition register_user(user_address: ByStr20, twitter_username: String)
    sender_is_owner = builtin eq owner _sender;
    user_exists <- exists users[twitter_username];
    user_does_not_exist = negb user_exists;
    can_register = andb sender_is_owner user_does_not_exist;
    match can_register with
    | False =>
        e = {_eventname : "user_registration_failed";
                user_address: user_address;
                twitter_username: twitter_username;
                sender: _sender;
                code: registration_error_code };
      event e
    | True =>
        users[twitter_username] := user_address;
        e = {_eventname : "user_registration_successful";
                user_address: user_address;
                twitter_username: twitter_username;
                sender: _sender;
                code: registered_success_code };
        event e
    end
end


(* this is sent by the owner *)
transition verify_tweet_pay (
  twitter_username: String,
  tweet_id: String, tweet_text: String,
  start_pos: Uint32, end_pos: Uint32)

  hashtag_length <- hashtag_length;
  is_owner = builtin eq _sender owner;
  is_already_verified <- exists verified_tweets[tweet_id];
  is_not_already_verified = negb is_already_verified;
  (* Check if described substring of tweet is valid (to avoid errors). *)
  tweet_length = builtin strlen tweet_text;
  valid_end_pos = builtin lt end_pos tweet_length;
  valid_start_pos = builtin lt start_pos end_pos;
  valid_substr = uint32_le tweet_length hashtag_length;
  is_valid_substring = let t = andb valid_start_pos valid_end_pos in andb t valid_substr;
  is_valid = let t = andb is_valid_substring is_owner in andb t is_not_already_verified;

  registered_address <- users[twitter_username];
  is_valid_registered_address = Pair {Bool (Option ByStr20)} is_valid registered_address;

  match is_valid_registered_address with
  | Pair True (Some regaddr) =>
    (* We know that substr will not raise an exception since we checked earlier. *)
    match_hashtag = builtin substr tweet_text start_pos hashtag_length;
    is_hashtag = builtin eq match_hashtag hashtag;
    (* Has it been a day since previous award?. *)
    withdrawal <- last_withdrawal[regaddr];
    current_block <- & BLOCKNUMBER;
    it_has_been_a_day =
      match withdrawal with
      | Some withdrawal =>
        let last_withdraw_block = withdrawal in
        let next_day_block = builtin badd last_withdraw_block blocks_per_day in
        let not_next_day_yet = builtin blt current_block next_day_block in
        negb not_next_day_yet
      | None => True
      end
    ;
    good_to_award = andb is_hashtag it_has_been_a_day;
    match good_to_award with
    | False =>
      e = {_eventname : "verify_tweet_pay_failed";
           sender: _sender;
           twitter_username: twitter_username;
           tweet_id: tweet_id;
           code: invalid_submission };
      event e
    | True =>
      verified_tweets[tweet_id] := regaddr;
      last_withdrawal[regaddr] := current_block;
      e = {_eventname : "verify_tweet_pay_successful";
           sender: _sender;
           recipient: regaddr;
           reward_amount: zils_per_tweet;
           tweet_id: tweet_id;
           code: verify_tweet_success_code };
      event e;
      msg = {_tag: "";
             _recipient: regaddr;
             _amount: zils_per_tweet;
             code: verify_tweet_success_code };
      msgs = one_msg msg;
      send msgs
    end
  | _ =>
    e = {_eventname : "verify_tweet_pay_failed";
         sender: _sender;
         twitter_username: twitter_username;
         tweet_id: tweet_id;
         code: invalid_submission };
    event e
  end
end
